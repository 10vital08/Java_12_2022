package HomeWork_3;

public class program {
	// С помошью неполной НЕУБЫВАЮЩЕЙ кучи крупные элементы закидываем поближе к
	// концу массива
	static void reheap(int arr[], int length, int i) throws Exception {

		// С этим родителем ещё не разобрались
		boolean done = false;

		// Запоминаем отдельно родителя и смотрим на его потомка слева
		int T = arr[i];
		int parent = i;
		int child = 2 * (i + 1) - 1;

		// Просматриваем потомков, а также потомков потомков
		// и сравниваем их с родителем (если что - передвигаем потомков влево)
		// Цикл продолжается пока не выпадем за пределы массива или пока не обменяем
		// какого-нибудь потомка на родителя.
		while ((child < length) && (!done)) {
			// Если правый потомок в пределах массива
			if (child < length - 1) {
				// То из левого и правого потомка выбираем наименьшего
				if (arr[child] >= arr[child + 1]) {
					child += 1;
				}
			}

			// Родитель меньше потомков?
			if (T < arr[child]) {

				// Тогда с этим родителем и его потомками разобрались
				done = true;

				// Родитель НЕ меньше чем наименьший из его потомков.
				// Перемещаем потомка на место родителя и с родителем в цикле сравниваем уже
				// потомков этого потомка
			} else {

				arr[parent] = arr[child];
				parent = child;
				child = 2 * (parent + 1) - 1;

			}
		}

		// Родитель, с которого всё начиналось передвигается ближе к концу массива (или
		// остаётся на месте, если не повезло)
		arr[parent] = T;

	}

	// С помошью неполной НЕВОЗРАСТАЮЩЕЙ кучи
	// мелкие элементы закидываем поближе к началу массива
	static void invreheap(int a[], int length, int i) throws Exception {

		// С этим родителем ещё не разобрались
		boolean done = false;

		// Запоминаем отдельно родителя и смотрим на его потомка слева
		int T = a[length - 1 - i];
		int parent = i;
		int child = 2 * (i + 1) - 1;

		// Просматриваем потомков, а также потомков потомков и сравниваем их с родителем
		// (если что - передвигаем потомков)
		// Цикл продолжается пока не выпадем за пределы массива или пока не обменяем
		// какого-нибудь потомка на родителя.
		while ((child < length) && (!done)) {

			// Если левый потомок в пределах массива
			if (child < length - 1) {

				// То из левого и правого потомка выбираем наибольшего
				if (a[length - 1 - child] <= a[length - 1 - (child + 1)]) {
					child += 1;
				}

			}

			// Родитель больше потомков?
			if (T > a[length - 1 - child]) {

				// Тогда с этим родителем и его потомками разобрались
				done = true;

			} else {

				// Родитель НЕ больше чем наибольший из его потомков.
				// Перемещаем потомка на место родителя и с родителем в цикле сравниваем уже
				// потомков этого потомка
				a[length - 1 - parent] = a[length - 1 - child];
				parent = child;
				child = 2 * (parent + 1) - 1;

			}
		}

		// Родитель, с которого всё начиналось передвигается ближе к началу массива (или
		// остаётся на месте, если не повезло)
		a[length - 1 - parent] = T;

	}

	// Основная процедура сортировки
	static void sort(int arr[]) throws Exception {

		// Строим неубывающую кучу
		// Большие элементы из начала массива закидываем поближе к концу
		for (int i = arr.length - 1; i >= 0; i--)
			reheap(arr, arr.length, i);

		// Строим невозрастающую кучу
		// Меньшие элементы из конца массива закидываем поближе к началу
		for (int i = arr.length - 1; i >= 0; i--)
			invreheap(arr, arr.length, i);

		// Досортировка вставками
		for (int j = 1; j < arr.length; j++) {
			int T = arr[j];
			int i = j - 1;
			while (i >= 0 && arr[i] > T) {
				arr[i + 1] = arr[i];
				i -= 1;
			}
			arr[i + 1] = T;
		}
	}

	// печать массива
	public static void PrintArray(int[] arr) {
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
	}

	public static void main(String[] args) throws Exception {
		int[] array = new int[] { 1, 2, 4, 6, 20, 19, 18, 16, 8, 3, 10, 5, 7, 9, 11, 12, 13, 14, 15, 17 };
		sort(array);
		PrintArray(array);
	}
}
